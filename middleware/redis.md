## Redis

Redis 是一个分布式内存 NoSQL 数据库，它以键值对的形式存储数据，也可以将存储到内存中的数据持久化到硬盘上，可以使用复制特性来扩展读性能，还可以使用客户端分片来扩展写性能。



### 1. 数据结构

Redis 支持的数据结构有：

1. STRING 字符串：可以是字符串、整数或浮点数

2. LIST 列表：使用的数据结构为链表，链表的每个节点都包含了一个字符串

3. SET 集合：包含字符串的无序集合，使用的数据结构为散列表

4. HASH 散列：字符串成员 Member 与浮点数分值 Score 之间的映射，元素的排列顺序由分值的大小决定

5. ZSET 有序集合：数据结构为跳表 SkipList



#### 1.1 字符串 String

底层的数据结构为一个字符数组。

命令：


>SET hello world # 将键 hello 的值设为 world

>GET hello # 获取 hello 对应的值，不存在则返回 NIL

>DEL hello # 删除 hello 对应的键值对



#### 1.2 列表 List

底层的数据结构为一个双向链表。

命令：


>LPUSH(RPUSH) list-key item # 将元素 item 从左(右)边添加进列表，返回列表当前的长度

>LPOP(RPOP) list-key # 用列表左(右)边弹出一个元素

>LRANGE list-key 0 -1 # 获取 list-key 对应的列表在给定范围上的所有值

>LINDEX list-key 1 # 获取列表在给定位置上的元素



#### 1.3 集合 Set

底层的数据结构为一个HashSet（本质上也是哈希表）。



列表和集合都可以存储多个字符串，但是：

1. 列表可以存储相同的字符串
2. 集合只能存储各不相同的字符串，因为：1. 集合的定义 2. 集合是使用散列表进行存储

命令：


>SADD set-key item # 将元素 item 添加进集合，返回1表示成功，0表示已经存在

>SMEMBERS set-key # 返回集合中所有的元素

>SISMEMBER set-key item # 检查元素 item 是否已经在集合中

>SREM set-key item2 # 如果元素 item 已经在集合中，则移除



#### 1.4 散列

底层的数据结构为一个哈希表。

散列可以存储多个键值对之间的映射



命令：


>HSET hash-key sub-key sub-item # 将sub-key:sub-item 键值对添加进散列中，返回1表示成功，0表示已经存在

>HGET hash-key sub-key # 获取散列中某个键的值

>HGETALL hash-key # 获取散列中所有键值

>HDEL hash-key sub-key # 如果给定键已经在散列中，则移除



**渐进式 rehash**

大字典的扩容是比较耗时间的，需要重新申请新的数组，然后将旧字典所有链表中的元素重新挂接到新的数组下面，这是一个 O(n) 级别的操作，作为单线程的 Redis 很难承受这样耗时的过程，所以 Redis 使用 **渐进式 rehash** 小步搬迁：渐进式 rehash 会在 rehash 的同时，保留新旧两个 hash 结构，如上图所示，查询时会同时查询两个 hash 结构，然后在后续的定时任务以及 hash 操作指令中，循序渐进的把旧字典的内容迁移到新字典中。当搬迁完成了，就会使用新的 hash 结构取而代之。



#### 1.5 有序集合 ZSet

底层的数据结构为 SkipList 跳表。

跳跃表的机制大致为：

最下面一层所有的元素都会串联起来，然后每隔几个元素就会挑选出一个“代表”，再把这几个代表使用另外一级指针串起来。然后再在这些代表里面挑出二级代表，再串起来。**最终形成了一个金字塔的结构。** 这样在范围查找的时候就更高效。



有序集合和散列一样，都用于存储键值对：有序集合的键被称为成员，每个成员各不相同；有序集合的值成为分值，分值必须为浮点数。有序集合是唯一一个既可以根据成员访问元素又可以根据分值以及分值顺序来访问元素的结构。

>ZADD zset-key score member # 将给定 score 的 member 添加进有序集合，返回1表示成功，0表示已经存在

>ZRANGE zset-key 0 -1 # 按照顺序获取有序集合在给定范围上的所有值

>ZRANGEBYSCORE zset-key 0 800 # 获取有序集合在给定分值范围上的所有值

>ZREM zset-key member # 如果元素 member 已经在有序集合中，则移除



### 2. 用例

#### 2.1 登录和 Session

当我们登录时，服务端一般需要记录用户的一些数据，把这些数据存在 Session 中，每个Session 有对应的唯一的 Session ID，前端通过 Cookie 存储 Session ID，并在请求时放在 cookie 这个 Header 中。



我们可以使用一个散列 login 来存储SeesionID 与 对应用户ID 的映射关系。如果需要将 Session 存在 Redis 中，那么可以使用 `login:session_id` 作为一个散列名，在这个散列中存储我们需要的信息，如用户ID。



#### 2.2 文章投票

支持按照文章发布顺序排序，和按照文章得票数来排序。

1. 使用 `article: 文章id`作为一个散列名，在这个散列中存储一篇文章的重要信息。
2. 使用两个有序集合来有序地存储文章：第一个有序集合的成员为 文章ID，分值则为文章得票数；第二个有序集合的成员为 文章ID，分值则为文章发布时间；

为了防止刷票，我们使用一个集合`vote: 文章ID `来记录投票的用户ID。

我们可以**通过EXPIRE 命令**设置这个集合的有效期，例如一周，这样一周后这个集合被删除，则不能进行投票。



#### 2.3 自动补全

1. 最近联系人，给每个人创建一个最近联系人列表，定期更新并且保证它的长度在规定范围内。
2. 前缀补全：利用有序集合的一个特点：当成员分值都相同，成员被按照成员名进行排序。当成员分值都为0，成员按照字符串的二进制顺序进行排序。这样，将名称存进有序集合，分值设置为0，然后进行范围查找。



#### 2.4 搜索

搜索基于反向索引。例如对于文章的搜索，我们对一篇文章进行预处理（例如去除一些非用词，“是”，“的”），从而提取出一部分单词，利用集合`inverted_indexes: word`来存储对应的文章ID。



1. 预处理，建立反向索引
2. 搜索：交集搜索，并集搜索，差集搜索
3. 利用有序集合对搜索结果进行排序
## Kafka

Kafka 是一个基于发布和订阅机制的消息系统。



### 1. 概念

#### 1.1 消息和批次

1. Kafka 的数据单元被称为**消息**。消息由**字节数组**组成，因此对 Kafka 来说，并不关心数据的格式。
2. 为了提高效率，消息被分批写入 Kafka，**批次**就是一组消息，一个批次的消息属于同一主题和分区。



#### 1.2 主题和分区

1. Kafka 通过**主题**对消息进行分类。
2. 一个主题可以被分为多个**分区**，一个分区具有一个**提交日志**，消息以**追加**的方式写入分区。通过分区，一个主题可以横跨多个服务器。

**流** 就是一组从生产中移动到消费者的数据。



#### 1.3 生产者和消费者

Kafka 的客户端就是 Kafka 系统的用户。用户被分为**生产者**和**消费者**。

1. **生产者**负责创建消息。默认情况下会把消息均衡的分布到主题的所有分区上，并不关心一个特定消息会被写入哪个分区。
2. **消费者**负责读取消息。消费者通过检查消息的**偏移量**来区分已经读取过的消息。**偏移量**是另一种元数据，它是一个不断递增的整数值。（元数据主要是描述数据属性（property）的信息，用来支持如指示存储位置、历史数据、资源查找、文件记录等功能。）
3. 消费者是**消费者群组**的一部分，会有一个或多个消费者读取同一个主题，群组用来保证一个分区只会被一个消费者使用，而一个消费者可以读取多个分区。



#### 1.4 Broker 和集群

1. 一个独立的 Kafka 服务器被称为 **Broker**。Broker 接收来自生产者的消息，为消息设置偏移量，并提交到磁盘进行保存。Broker 为消费者提供服务，对读取分区的请求作出响应，返回已经提交到磁盘上的消息。
2. Broker 是**集群**的组成部分。每个集群都有一个 Broker 同时充当了**集群控制器**的角色。
3. 一个分区从属于一个 Broker，这个 Broker 就被称为分区的**首领**。一个分区可以分配给多个 Broker，这时候就会发生**分区复制**。这样一个 Broker失效，其它 Broker 则可以接管领导权。
4. **保留消息**。Kafka 的策略为，要么保留一段时间（例如一周），要么将消息保留到一定大小的字节数（超限则删除旧的消息）。

使用多个集群可以实现：

1. 数据类型分离
2. 安全需求隔离
3. 多数据中心（灾难恢复

 Kafka 提供了一个叫 MirrorMaker 工具，实现集群之间的复制。



### 2. 生产者

一个应用程序在很多情况下都需要往 Kafka 内写入消息，例如用户的活动，保存日志消息，缓冲即将写入数据库的数据。

生产者写入一条消息的过程：

1. 创建一个 ProducerRecord 对象，这个对象必须包含目标主题和发布内容。也可以额外指定键或分区。然后序列化为字节数组，从而在网络上传输。
2. 数据被发送到分区器，如果之前指定了分区，那么分区器就不会再做任何事情，直接把指定的分区返回；如果没有指定，那么会根据 ProducerRecord 的键来选择一个分区。
3. 这个记录被添加到一个批次中，有一个独立的线程负责把这些记录批次发送到相应的 Broker 上。
4. 服务器在收到这些消息时，会做出一个响应。如果写入成功，则返回一个  RecordMetaData 对象，它包含了主题和分区信息以及在分区中的偏移量。如果写入失败，则返回一个错误。

Kafka 可以保证如果生产者按照一定的顺序发送消息，那么Broker也会按照这个顺序把它们写入分区，消费者也会按照这个顺序来读取。



### 3. 消费者

一个消费者属于一个消费者群组，一个群组订阅的是同一个主题。

当一个新的消费者加入，或者一个消费者被关闭或发生崩溃离开群组，原本由他读取的分区将由其它消费者来读取。分区的所有权从一个消费者转移到另一个消费者，这个行为叫做**再均衡**。再均衡期间，整个群组一段时间内不可用。

消费者通过向被指派为**群组协调器**的 Broker 发送**心跳**来维持它们和群组的从属关系以及它们对分区的所有权关系。



### 4. 集群

#### 控制器

集群里第一个启动的 Broker 通过在 Zookeeper 里面创建一个临时节点 /controller 来让自己成为控制器。其它 Broker 启动时也试图创建，会得到通知该节点已存在。这时会在控制器节点上 创建 Zookeeper watch对象，以便在控制器节点发生变化时得到通知。



当控制器节点退出或发生崩溃，Zookeeper上的临时节点会消失，其它 Broker 得到通知，会试图创建节点，第一个成功创建的就是新的控制器。



控制器负责分区首领的选举。



#### 副本

1. 首领副本。每个集群都有一个首领副本，所有读写请求都经过这个副本。
2. 跟随者副本。首领以外的副本都叫跟随者副本。跟随者副本唯一的任务就是从首领处复制消息，保持同步。如果首领崩溃，其中一个会被提升为新的首领。



首领的另一个任务就是搞清楚哪个跟随者的状态和自己是一致的。保持一致的叫做**同步的副本**。只有同步的副本才会被选举为新首领。

